rec[i, 3] <- mean(g)
# naive <- matrix(Yc[, 1]^2 * lm_out$res , ncol = 1)
# rec[i, 2] <- emplik::el.test(naive, mu = rep(0, ncol(naive)))$Pval
rec[i, 4] <- mean(m1)
if(i %% 100 == 0){
cat("iter: ")
cat(i)
cat("\n")
}
}
colMeans(rec[,1:2] < .1)
colMeans(rec[,3:4])
knitr::opts_chunk$set(echo = TRUE)
se_binary <- function(p, n){
se <- sqrt(p * (1-p) /n )
return(se)
}
se_binary(.4, 1000)
library(disjointCycles)
library(disjointCycles)
sample.size <- 200
rep.runs <- 10
n.list <- c(10, 25, 50) * 1000
c.list <- c(2, 3, 4)
a.list <- c(.05, .01, .001, 1e-4, 1e-5)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), c.list, a.list)
param.grid
6 * 4
agTab <- aggregate(cbind(gamma_order, mixNorm_order, gamma_oracle_sen, mixNorm_oracle_sen, gamma_oracle_spc , mixNorm_oracle_spc,
gamma_graph_oracle = gamma_oracle_sen == 1 & gamma_oracle_spc == 1, mixNorm_graph_oracle =mixNorm_oracle_sen == 1 & mixNorm_oracle_spc == 1,
gamma_est_spc, mixNorm_est_spc, gamma_est_sen, mixNorm_est_sen,
gamma_graph_est = gamma_est_sen == 1 & gamma_est_spc == 1,
mixNorm_graph_est = mixNorm_est_sen == 1 & mixNorm_est_spc == 1)~
n + cycLen + alpha, data = outTabComp, FUN = mean)
outTabComp
sample.size <- 200
rep.runs <- 10
n.list <- c(10, 25, 50) * 1000
c.list <- c(2, 3, 4)
a.list <- c(.05, .01, .001, 1e-4, 1e-5)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), c.list, a.list)
# 450
runInd <- 1
outTabComp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_",runInd, ".csv", sep = ""),)
colnames(outTabComp) <- c("cycLen", "alpha", "n", paste(rep(c("gamma", "mixNorm"), each = 5), rep(c("order", "oracle_sen", "oracle_spc", "est_sen", "est_spc"), times= 2), sep = "_"))
missing <- c()
for(runInd in 2:nrow(param.grid)){
if(!file.exists(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_", runInd, ".csv", sep = ""))){
missing <- c(missing, runInd)
} else {
temp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_", runInd, ".csv", sep = ""))
colnames(temp) <- c("cycLen", "alpha", "n", paste(rep(c("gamma", "mixNorm"), each = 5), rep(c("order", "oracle_sen", "oracle_spc", "est_sen", "est_spc"), times= 2), sep = "_"))
outTabComp <- rbind(outTabComp, temp)
}
}
missing
agTab <- aggregate(cbind(gamma_order, mixNorm_order, gamma_oracle_sen, mixNorm_oracle_sen, gamma_oracle_spc , mixNorm_oracle_spc,
gamma_graph_oracle = gamma_oracle_sen == 1 & gamma_oracle_spc == 1, mixNorm_graph_oracle =mixNorm_oracle_sen == 1 & mixNorm_oracle_spc == 1,
gamma_est_spc, mixNorm_est_spc, gamma_est_sen, mixNorm_est_sen,
gamma_graph_est = gamma_est_sen == 1 & gamma_est_spc == 1,
mixNorm_graph_est = mixNorm_est_sen == 1 & mixNorm_est_spc == 1)~
n + cycLen + alpha, data = outTabComp, FUN = mean)
agTab2 <- aggregate(cbind(gamma_order, mixNorm_order, gamma_oracle_sen, mixNorm_oracle_sen, gamma_oracle_spc , mixNorm_oracle_spc,
gamma_graph_oracle, mixNorm_graph_oracle,
gamma_est_spc, mixNorm_est_spc, gamma_est_sen, mixNorm_est_sen,
gamma_graph_est, mixNorm_graph_est
)~ n + cycLen, data = agTab, FUN = max)
agTab2
p <- 10
cycleSize <- 4
alpha <- .001
n <- 50000
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
trueAdj
Lambda
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
library(disjointCycles)
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
est_ord <- djcGetOrder(scale(data$Y), verbose = F, alpha2 = alpha, alpha3 = alpha, alphaR = alpha)
rec[i, 1] <- compareOrders(trueGraph, est_ord)
est_ord
est_Edges <- djcGetEdges(trueGraph, scale(data$Y, scale = T), alpha = alpha)
est_Edges
est_Edges$adjMat
trueAdj
round(est_Edges$Lambda,4)
alpha
alpha <- 1e-5
final_ord <- djcGetEdges(est_ord, scale(data$Y, scale = T), alpha = alpha)
round(est_Edges$Lambda,4)
cycleChain()
cycleSize
C <- 1:6
D <- 7:10
moments <- calcSandT(data$Y)
sMat <- moments$sMat
tMat <- moments$tMat
alpha <- .01
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
Y <- data$Y
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
Lambda_DD
data$Lambda
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
Lambda_CD
Lambda_DD$Lambda[, d]
d <- 1
D[d]
Lambda_DD$Lambda[, D[d]]
Lambda_DD
d
Lambda_DD$Lambda[, d]
Y[, D]
Y[, D[d]] - Y[, C] %*% Lambda_CD_null - Y[, D] %*% Lambda_DD$Lambda[, d]
Lambda_CD_null <- Lambda_CD
c <- 1
Lambda_CD_null
Lambda_CD_null
Lambda_CD_null <- Lambda_CD
Lambda_CD_null[c, d] <- 0
errD_null <- Y[, D[d]] - Y[, C] %*% Lambda_CD_null[, d] - Y[, D] %*% Lambda_DD$Lambda[, d]
pruneParents1 <- function(C, D, sMat, tMat, Y, alpha, subsample = nrow(Y)){
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
for(d in 1:length(D)){
for(c in 1:length(C)){
Lambda_CD_null <- Lambda_CD
Lambda_CD_null[c, d] <- 0
errD_null <- Y[, D[d]] - Y[, C] %*% Lambda_CD_null[, d] - Y[, D] %*% Lambda_DD$Lambda[, d]
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C[c]]^2), subsample = subsample)
}
}
pvals_CD <- matrix(p.adjust(pvals_CD, method = "holm"), nrow = length(C))
Lambda[1:length(C), 1:length(D)] <- Lambda_CD * (pvals_CD <= alpha)
adj_CD[1:length(C), 1:length(D)] <-  (pvals_CD <= alpha) + 0
Lambda[length(C)+ 1:length(D), 1:length(D)] <- Lambda_DD$Lambda
adj_CD[length(C) + 1:length(D), 1:length(D)] <- Lambda_DD$adj
return(list(adj_CD = adj_CD, Lambda_CD = Lambda))
}
pruneParents1 <- function(C, D, sMat, tMat, Y, alpha){
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
for(d in 1:length(D)){
for(c in 1:length(C)){
Lambda_CD_null <- Lambda_CD
Lambda_CD_null[c, d] <- 0
errD_null <- Y[, D[d]] - Y[, C] %*% Lambda_CD_null[, d] - Y[, D] %*% Lambda_DD$Lambda[, d]
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C[c]]^2))
}
}
pvals_CD <- matrix(p.adjust(pvals_CD, method = "holm"), nrow = length(C))
Lambda[1:length(C), 1:length(D)] <- Lambda_CD * (pvals_CD <= alpha)
adj_CD[1:length(C), 1:length(D)] <-  (pvals_CD <= alpha) + 0
Lambda[length(C)+ 1:length(D), 1:length(D)] <- Lambda_DD$Lambda
adj_CD[length(C) + 1:length(D), 1:length(D)] <- Lambda_DD$adj
return(list(adj_CD = adj_CD, Lambda_CD = Lambda))
}
moments <- calcSandT(data$Y)
out <- pruneParents1(C = 1:(p-cycleSize), (p- cycleSiZe + 1):p,
moments$sMat, moments$tMat, data$Y, alpha = .001)
moments <- calcSandT(data$Y)
out <- pruneParents1(C = 1:(p-cycleSize), (p- cycleSize + 1):p,
moments$sMat, moments$tMat, data$Y, alpha = .001)
out
Lambda[1:(p-cycleSize), (p- cycleSize + 1):p]
Lambda[1:(p-cycleSize), (p- cycleSize + 1):p]
Lambda
p <- 10
cycleSize <- 4
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
p <- 10
cycleSize <- 4
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
moments <- calcSandT(data$Y)
out <- pruneParents1(C = 1:(p-cycleSize), D = (p- cycleSize + 1):p,
moments$sMat, moments$tMat, data$Y, alpha = .001)
out$Lambda_CD
out$Lambda_CD
Lambda[1:(p-cycleSize), (p- cycleSize + 1):p]
out$Lambda_CD
Lambda[, (p- cycleSize + 1):p]
library(disjointCycles)
sample.size <- 200
rep.runs <- 10
n.list <- c(10, 25, 50) * 1000
c.list <- c(2, 3, 4)
a.list <- c(.05, .01, .001, 1e-4, 1e-5)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), c.list, a.list)
# 450
runInd <- 1
outTabComp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_",runInd, ".csv", sep = ""),)
colnames(outTabComp) <- c("cycLen", "alpha", "n", paste(rep(c("gamma", "mixNorm"), each = 5), rep(c("order", "oracle_sen", "oracle_spc", "est_sen", "est_spc"), times= 2), sep = "_"))
missing <- c()
for(runInd in 2:nrow(param.grid)){
if(!file.exists(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_", runInd, ".csv", sep = ""))){
missing <- c(missing, runInd)
} else {
temp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/singleCycle/singleCycle_", runInd, ".csv", sep = ""))
colnames(temp) <- c("cycLen", "alpha", "n", paste(rep(c("gamma", "mixNorm"), each = 5), rep(c("order", "oracle_sen", "oracle_spc", "est_sen", "est_spc"), times= 2), sep = "_"))
outTabComp <- rbind(outTabComp, temp)
}
}
missing
agTab <- aggregate(cbind(gamma_order, mixNorm_order, gamma_oracle_sen, mixNorm_oracle_sen, gamma_oracle_spc , mixNorm_oracle_spc,
gamma_graph_oracle = gamma_oracle_sen == 1 & gamma_oracle_spc == 1, mixNorm_graph_oracle =mixNorm_oracle_sen == 1 & mixNorm_oracle_spc == 1,
gamma_est_spc, mixNorm_est_spc, gamma_est_sen, mixNorm_est_sen,
gamma_graph_est = gamma_est_sen == 1 & gamma_est_spc == 1,
mixNorm_graph_est = mixNorm_est_sen == 1 & mixNorm_est_spc == 1)~
n + cycLen + alpha, data = outTabComp, FUN = mean)
agTab
agTab2 <- aggregate(cbind(gamma_order, mixNorm_order, gamma_oracle_sen, mixNorm_oracle_sen, gamma_oracle_spc , mixNorm_oracle_spc,
gamma_graph_oracle, mixNorm_graph_oracle,
gamma_est_spc, mixNorm_est_spc, gamma_est_sen, mixNorm_est_sen,
gamma_graph_est, mixNorm_graph_est
)~ n + cycLen, data = agTab, FUN = max)
agTab2
agTab2
agTab2[, c("gamma_graph_oracle","mixNorm_graph_oracle")]
agTab2[, c("n","cycLen", "gamma_graph_oracle","mixNorm_graph_oracle")]
p <- 10
cycleSize <- 4
n <- 50000
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
moments <- calcSandT(data$Y)
out <- pruneParents1(C = 1:(p-cycleSize), D = (p- cycleSize + 1):p,
moments$sMat, moments$tMat, data$Y, alpha = .001)
out
out$adj_CD - trueAdj[, (p-cycleSize + 1):p]
trueAdj
trueAdj
Lambda
round(Lambda[, (p-cycleSize + 1):p], 3)
round(Lambda[, (p-cycleSize + 1):p], 2)
round(Lambda[, (p-cycleSize + 1):p], 2)
round(out$Lambda_CD,2)
moments <- calcSandT(data$Y)
out <- pruneParents(C = 1:(p-cycleSize), D = (p- cycleSize + 1):p,
moments$sMat, moments$tMat, data$Y, alpha = .001)
round(Lambda[, (p-cycleSize + 1):p], 2)
round(out$Lambda_CD,2)
Lambda
lambdaTrue <- Lambda
C <- 1:(p-cycleSize)
D <- (p-cycleSize + 1):p
moments <- calcSandT(data$Y)
sMat <- moments$sMat; tMat <- moments$tMat
Y <- data$Y
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
colMeans(Y)
Lambda_DD
lambdaTrue
Y_D_adjusted[,1]
for(d in 1:length(D)){
Y_D_adjusted2[, d] <- lm(Y[, D[d]] ~ Y[,C])$res
}
Y_D_adjusted2 <- matrix(0, n, length(D))
for(d in 1:length(D)){
Y_D_adjusted2[, d] <- lm(Y[, D[d]] ~ Y[,C])$res
}
cov(Y_D_adjusted)
cov(Y_D_adjusted2)
cov(Y_D_adjusted) - cov(Y_D_adjusted2)
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
?write.csv
pruneParents1 <- function(C, D, sMat, tMat, Y, alpha, oracleDat = NULL,
oracleLambdaD = NULL, infFunc = F){
testAll <- F
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
if(!is.null(oracleDat)){
adjMoments <- calcSandT(oracleDat)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
} else if(!is.null(oracleLambdaD)){
Lambda_DD <- list(adj = (oracleLambdaD != 0), Lambda = oracleLambdaD)
} else {
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
}
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
for(d in 1:length(D)){
for(c in 1:length(C)){
Lambda_CD_null <- Lambda_CD
Lambda_CD_null[c, d] <- 0
errD_null <- Y[, D[d]] - Y[, C] %*% Lambda_CD_null[, d] - Y[, D] %*% Lambda_DD$Lambda[, d]
### Test independence from all C, or just specific c
if(testAll){
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C]^2))
} else {
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C[c]]^2))
}
}
}
pvals_CD_raw <- pvals_CD
pvals_CD <- matrix(p.adjust(pvals_CD, method = "holm"), nrow = length(C))
Lambda[1:length(C), 1:length(D)] <- Lambda_CD * (pvals_CD <= alpha)
adj_CD[1:length(C), 1:length(D)] <- (pvals_CD <= alpha) + 0
Lambda[length(C)+ 1:length(D), 1:length(D)] <- Lambda_DD$Lambda
adj_CD[length(C) + 1:length(D), 1:length(D)] <- Lambda_DD$adj
return(list(adj_CD = adj_CD, Lambda_CD = Lambda, pvals_raw = pvals_CD_raw))
}
###########################
set.seed(100)
p <- 10
cycleSize <- 4
sim.size <- 200
n <- 50000
alpha <- .01
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
C <- 1:(p-cycleSize)
D <- (p-cycleSize + 1):p
rec <- rec1 <- rec2<- matrix(0, nrow = sim.size, ncol = sum(trueAdj[C,D] == 0))
for(i in 1:sim.size){
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
oracleReg <- solve(data$sigma[C,C]) %*% data$sigma[C,D]
Y <- data$Y
oracleDat <- Y[,D] - Y[, C] %*% oracleReg
moments <- calcSandT(Y)
out <- pruneParents1(C, D, moments$sMat, moments$tMat, Y, alpha)
rec[i, ] <- out$pvals_raw[which(trueAdj[C,D] == 0)]
out_dat <- pruneParents1(C, D, moments$sMat, moments$tMat, Y, alpha,
oracleDat = oracleDat)
rec1[i, ] <- out_dat$pvals_raw[which(trueAdj[C,D] == 0)]
out_lambda <- pruneParents1(C, D, moments$sMat, moments$tMat, Y,
alpha, oracleLambdaD = Lambda[D,D])
rec2[i, ] <- out_lambda$pvals_raw[which(trueAdj[C,D] == 0)]
cat(i)
cat("\n")
}
library(disjointCycles)
pruneParents1 <- function(C, D, sMat, tMat, Y, alpha, oracleDat = NULL,
oracleLambdaD = NULL, infFunc = F){
testAll <- F
adj_CD <- matrix(0, length(C) + length(D), length(D))
adj_CD[1:length(C), 1:length(D)] <- 1
Lambda <- matrix(0, length(C) + length(D), length(D))
pvals_CD <- matrix(0, length(C), length(D))
R_DC <- sMat[D,C] %*% solve(sMat[C,C])
if(!is.null(oracleDat)){
adjMoments <- calcSandT(oracleDat)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
} else if(!is.null(oracleLambdaD)){
Lambda_DD <- list(adj = (oracleLambdaD != 0), Lambda = oracleLambdaD)
} else {
Y_D_adjusted <- Y[, D] - Y[, C] %*% t(R_DC)
adjMoments <- calcSandT(Y_D_adjusted)
Lambda_DD <- disjointCycles::constructCycle(adjMoments$sMat, adjMoments$tMat)
}
Lambda_CD <- t(R_DC) %*% (diag(length(D)) - Lambda_DD$Lambda)
for(d in 1:length(D)){
for(c in 1:length(C)){
Lambda_CD_null <- Lambda_CD
Lambda_CD_null[c, d] <- 0
errD_null <- Y[, D[d]] - Y[, C] %*% Lambda_CD_null[, d] - Y[, D] %*% Lambda_DD$Lambda[, d]
### Test independence from all C, or just specific c
if(testAll){
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C]^2))
} else {
pvals_CD[c, d] <- disjointCycles::checkIndEL(errD_null, scale(Y[, C[c]]^2))
}
}
}
pvals_CD_raw <- pvals_CD
pvals_CD <- matrix(p.adjust(pvals_CD, method = "holm"), nrow = length(C))
Lambda[1:length(C), 1:length(D)] <- Lambda_CD * (pvals_CD <= alpha)
adj_CD[1:length(C), 1:length(D)] <- (pvals_CD <= alpha) + 0
Lambda[length(C)+ 1:length(D), 1:length(D)] <- Lambda_DD$Lambda
adj_CD[length(C) + 1:length(D), 1:length(D)] <- Lambda_DD$adj
return(list(adj_CD = adj_CD, Lambda_CD = Lambda, pvals_raw = pvals_CD_raw))
}
###########################
set.seed(100)
p <- 10
cycleSize <- 4
sim.size <- 200
n <- 50000
alpha <- .01
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
C <- 1:(p-cycleSize)
D <- (p-cycleSize + 1):p
rec <- rec1 <- rec2<- matrix(0, nrow = sim.size, ncol = sum(trueAdj[C,D] == 0))
for(i in 1:sim.size){
data <- rLSEM(p, n, dist = "gamma", LambdaIn = Lambda, lowScale = .8)
oracleReg <- solve(data$sigma[C,C]) %*% data$sigma[C,D]
Y <- data$Y
oracleDat <- Y[,D] - Y[, C] %*% oracleReg
moments <- calcSandT(Y)
out <- pruneParents1(C, D, moments$sMat, moments$tMat, Y, alpha)
rec[i, ] <- out$pvals_raw[which(trueAdj[C,D] == 0)]
out_dat <- pruneParents1(C, D, moments$sMat, moments$tMat, Y, alpha,
oracleDat = oracleDat)
rec1[i, ] <- out_dat$pvals_raw[which(trueAdj[C,D] == 0)]
out_lambda <- pruneParents1(C, D, moments$sMat, moments$tMat, Y,
alpha, oracleLambdaD = Lambda[D,D])
rec2[i, ] <- out_lambda$pvals_raw[which(trueAdj[C,D] == 0)]
cat(i)
cat("\n")
}
sample.size <- 1000
rep.runs <- 10
n.list <- c(10, 25, 50) * 1000
c.list <- c(4)
alpha <- .05
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), c.list)
runInd <- 1
outTabComp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/pvals/pvals_",runInd, ".csv", sep = ""),)
missing <- c()
for(runInd in 2:nrow(param.grid)){
if(!file.exists(paste("~/Dropbox/disjointCycles/simResults/pvals/pvals_", runInd, ".csv", sep = ""))){
missing <- c(missing, runInd)
} else {
temp <- read.csv(paste("~/Dropbox/disjointCycles/simResults/pvals/pvals_", runInd, ".csv", sep = ""))
outTabComp <- rbind(outTabComp, temp)
}
}
missing
tab <- aggregate(cbind(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12) < .05 ~ n + type,
data = outTabComp, FUN = mean)
tab
which(tab[6,] > .07)
which(tab[6,] > .1)
which(tab[6,-c(1:2)] > .1)
which(tester == 0)[c(8,11, 12)]
sample.size <- 1000
rep.runs <- 10
n.list <- c(10, 25, 50) * 1000
c.list <- c(4)
alpha <- .05
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), c.list)
p <- 10
cycleSize <- param.grid[runInd, 2]
n <- param.grid[runInd, 1]
set.seed(100)
trueAdj <- matrix(0, p, p)
trueAdj[matrix(c((p-cycleSize + 1):p, c(p-cycleSize + 2):p, p-cycleSize + 1) , ncol = 2)] <- 1
trueAdj[1:(p-cycleSize), (p-cycleSize + 1):p] <- rbinom((p-cycleSize) * cycleSize, size = 1, prob = 1/2)
Lambda <- trueAdj * runif(p^2, .3, .9) * sample(c(-1, 1), size = p^2, replace = T)
trueGraph <- list(as.list(1:(p-cycleSize)),list(c(p-cycleSize + 1):p))
C <- 1:(p-cycleSize)
D <- (p-cycleSize + 1):p
rec <- rec1 <- rec2 <- rec3 <-  matrix(0, nrow = rep.runs, ncol = sum(trueAdj[C,D] == 0))
tester <- Lambda[C,D]
which(tester == 0)[c(8,11, 12)]
tester[c(13,18,19)] <- -2
tester
